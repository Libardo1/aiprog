
Introduction

???

К примеру, мы просим своего друга-гумманитария, сделать следующее:
"Вот массив данных, построй регрессию, степень полинома выбери по кросс-валидационной выборке в 10%, и скажи мне какая результирующая ошибка будет на тестовой выборке в 10%"
Друг тут же спросит в ответ:
"А что такое регрессия? Кросс-валидация? Тестовая выборка? Как считать результирующую ошибку?"
И тут возникает два пути ответить на эти вопросы:
Первый, это просто рассказать конретный метод регрессии с кросс-валидацией и подсчетом ошибки, перечислив шаг за шагом.
Второй же, это объяснить откуда и что береться, возможно спускаясь по лестнице терминов до сложения и умножения (друг-гумманитарий, уже все забыл).

Первый метод - это метод которым сейчас пишут программы. В чем его уязвимость? В том, что когда ты попросишь этого же друга посчитать регрессию, но добавить регуляризацию,
то придёться объяснять все с начала - так как у него не будет отдельных деталей в голове из которых можно сложить новую картинку - у него будет цельный план как делать то что вы ему объяснили до этого.

Второй же метод - метод который я и собираюсь исследовать в своей работе. Метод, когда мы объясням как и что нужно делать. В результате чего, в голове у нашего друга
будет много информации об этом, и когда я попрошу регрессию с регуляризацией, он только спросит, а как докрутить регуляризацию? Так как он уже спокойно владеет регрессией,
имеет знания о том, как и что получилось. То есть знания единожды внесенные, дальше "реиспользуются" для решения новых задач.

Эта идея, казалось бы, стоит за тем же объектно ориентированным программированием. Но как это не печально, хорошо работает она достаточно редко.
Основная причина - то что написав единожды класс, мы не можем предсказать всех последующих модификаций, а соответсвенно в него вносятся правки,
потом правки вносятся в наследников и так далее. 
Реиспользуемость наблюдается либо у очень базовых классов, либо же у хорошо продуманных, что к сожалению, тоже встречается редко.

То есть, цель данной работы это объеденить наработки по логическому выводу, доказательству теорем, синтезу алгоритмов, машинному обучению и получить в результате полезную
для разработчика утилиту, которая позволит сбросить рутинные действия на плечи компьютера.


Overview

